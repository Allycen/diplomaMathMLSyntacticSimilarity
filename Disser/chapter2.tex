\chapter{Модификация алгоритма Tree Overlapping для поиска схожести между выражениями в формате MathML} \label{chapt2_newAlgo}



  \section{Определение паттернов математической схожести} \label{chapt1_simPatterns}
      

      После рассмотрения видов разметки MathML в подразделе~\ref{chapt1__mathml}, в качестве разметки для определения синтаксической близости MathML выражений было решено взять за основу разметку Presentation Markup ввиду следующих соображений:

        \begin{itemize}
          \item многие элементы Content Markup отвечают за семантический смысл выражения или за отношения между его частями, что при отобрабражении не влияет на визуальное представление выражения, а следовательно и на синтаксическую структуру выражения;
          \item из-за богатого разнообразия элементов в Content Markup, некоторые операции, несущие разный семантический смысл, при отображении могут быть одинаковыми или очень похожими. В то же время Presentation Markup имеет фиксированный небольшой набор элементов, отвечающий за отображение конкретной конструкции выражения;
          \item в интернете наибольшее распространение получает Presentation Markup из-за того, что многие формулы, написанные на MathML, предназначены для визуального восприятия, а разметки Presentation Markup достаточно, чтобы визуально представить практически любое выражение необходимым образом.
        \end{itemize}
            

      Рассматриваемое MathML выражение решено представлять в виде упорядоченного ориентированного дерева $E_1$, с неограниченным количеством дочерних узлов. 
      Всем узлам дерева $v$ задать веса $w(v)$. В этом случае, весовая функция $w(T)$ дерева выражения или его части будет определяться как сумма весов всех узлов, которые в него входят. Общая часть деревьев $E_1$ и $E_2$ --- поддерево, полностью совпадающее с частью дерева $E_1$ и частью дерева $E_2$, а $E_1 \cap E_2$ --- набор всех общих частей деревьев $E_1$ и $E_2$. Формула, определяющая схожесть выражений $E_1$ и $E_2$, определена как:
      
      
      После рассмотрения методов определения схожести древовидных упорядоченных структур в разделе \ref{chapt1__sect_methods} и, при помощи работы \cite{patterns_mathml_similarity}, было решено определить синтаксическую схожесть математических выражений следующим образом:
      

        \begin{equation}
          \label{eq:simfunc}
          Sim(E_1, E_2) = \frac{w(E_1 \cap E_2)}{w(E_1)+w(E_2)}
        \end{equation}


      Также было решено ввести такой термин, как нормализация дерева выражения --- это обезличивание переменных и числовых значений (терминальных узлов).
      Решено использовать следующие паттерны, часть из которых были заимствованы из работы~\cite{patterns_mathml_similarity}, по возможной схожести мат. выражений:


        \begin{itemize}
          \item \textbf{Математическая эквивалентность}: $E_1$ и $E_2$ математически эквивалентны, если они семантически одинаковы (Пример: $\frac{d (sin(x))}{dx} = (sin(x))'$)

          \item \textbf{Идентичны}: $E_1$ и $E_2$ идентичны, если они абсолютны одинаковы.

          \item \textbf{Синтаксически идентичны}: $E_1$ и $E_2$ синтаксически идентичны, если идентичны после обезличивания переменных (Пример: $sin(a)$ = $sin(b)$)

          \item \textbf{n--схожи}: нормализованные $E_1$ и $E_2$ $n$-схожи, если $sim(E_1, E_2) \geqslant n$, где $n$ --- параметрическое значение, определяющее порог схожести двух выражений.
        
          \begin{enumerate}
            \item \textbf{$n$--схожесть подвыражений}: $E_1$ и $E_2$ $n$--схожи на уровне подвыражений, если у них существует общее поддерево, содержащее все терминальные узлы обоих деревьев (Пример: $six(x)^2$ и $\frac{sin(x)}{2}$, рис.~\ref{img:nsim-subexprsim})
            
            \item \textbf{Структурная $n$--схожесть}: $E_1$ и $E_2$ $n$--схожи и у них существует общая область, начинающаяся с корней обоих деревьев, из узлов с одинаковыми правилами перехода к последующим узлам. (Пример: $x + \sqrt{six(a)}$ и $x + \sqrt{2b}$, рис.~\ref{img:nsim-structuralsim})
          \end{enumerate}
        \end{itemize}


            \begin{figure}[ht] 
              \center
              \includegraphics[width=.75\linewidth]{img/tikzpictures/chapt_1/subexprSim}
              \caption{Структурная $n$--схожесть выражений $six(x)^2$ и $\frac{sin(x)}{2}$ представленных в формате MathML при $n \geqslant \frac{18}{26}$} 
              \label{img:nsim-subexprsim}  
            \end{figure}

            \begin{figure}[ht] 
              \center
              \includegraphics[width=.8\linewidth]{img/tikzpictures/chapt_1/structSim}
              \caption{$N$--схожесть подвыражений выражений $x + \sqrt{six(a)}$ и $x + \sqrt{2b}$, представленных в формате MathML при $n \geqslant \frac{12}{24}$} 
              \label{img:nsim-structuralsim}  
            \end{figure}

    
      На рис.~\ref{img:nsim-subexprsim} и рис.~\ref{img:nsim-structuralsim} в числителе неравенства --- суммарное количество общих узлов между деревьями, а в знаменателе --- суммарное количество всех узлов деревьев. Дробь формируется из формулы схожести математических выражений \ref{eq:simfunc}, представленной выше в этом же разделе.


      В качестве одного из алгоритмов, рассмотренных в разделе \ref{chapt1} было решено взять алгоритм, в основе которого метод наложения одного дерева на другой, который определяет схожесть количеством узлов с одинаковыми  правилами перехода между ними (параграф~\ref{chapt1__sect_methods__tree_overlap}), так как он ближе всего подходит для вычисления синтаксической схожести выражений, представленных в формате MathML.
  

  \section{Модификация алгоритма} \label{chapt2_newAlgo__modif}


    Алгоритм, выбранный за основу, не может быть использован без модификаций из-за того, что при расчете схожести деревьев между собой он:

      \begin{itemize}
        \item не учитывает одинаковые терминальные узлы;
        \item не учитывает одинаковые узлы, которые имеют одно и то же значение и которые стоят в том же самом порядке относительно своих родственных узлов, но не имеющих одинакового правила перехода от себя к другим узлам.
      \end{itemize}


    Для адаптации алгоритма для возможности поиска структурной схожести и схожести подвыражений математических выражений, представленных в формате MathML, решено было его модифицировать. 

    Прежде всего определим базовые понятия, неизменные для базового и модифицированного алгоритмов.

    В ходе наложения деревьев друг на друга в узлах $n_1$ первого дерева и $n_2$ второго дерева, образуется набор пар узлов $L(n_1, n_2)$ , которые также накладываются друг на друга. К примеру, при наложении дерева $T_1$ на дерево $T_2$ в узлах $a^1$ и $a^2$ на рис.~\ref{img:L_sample} этот набор пар будет равен $L(a_1, a_2) = \{(a^1,a^2), (b^1,h^2), (c^1,c^2), (d^1,d^2), (e^1,j^2), (f^1,f^2), (g^1,g^2)\}$.

      \begin{figure}[ht] 
        \center
        \includegraphics[width=.9\linewidth]{img/tikzpictures/chapt_2/L_sample}
        \caption{Пример наложения деревьев $T_0$ и $T_1$ в узлах $a^1$ и $a^2$}
        \label{img:L_sample}
      \end{figure}

    Пусть $ch(n,i)$ --- $i$-ый дочерний узел узла $n$. Тогда множество пар узлов $L(n_1, n_2)$ формируется следующим образом:
      \begin{enumerate} 
        \item $(n_1,n_2) \in L(n_1,n_2)$
        \item Если $(m_1,m_2) \in L(n_1,n_2)$, \\
              \phantom{  } то $(ch(m_1,i), ch(m_2,i)) \in L(n_1,n_2)$
        \item $L(n_1,n_2)$ включает в себя все пары узлов, сгенерированные рекурсивно пунктом номер~2.
      \end{enumerate} 
      \medskip
        
    

    Также согласно базовому алгоритму --- вводится понятие множества $N_{TO}(n_1,n_2)$. Оно определяется количеством нетерминальных пар узлов с одинаковыми правилами перехода и принадлежащими множеству накладываемых пар узлов при наложении одного дерева на другое в узлах $n_1$, $n_2$. $N_{TO}(n_1,n_2)$ выражается формулой~\ref{eq:base_Nto}:

      \begin{equation}
        \label{eq:base_Nto}
        N_{TO}(n_1,n_2) = 
        \left\{ (m_1,m_2) \,
        \begin{array}{|l}
                m_1 \in NT(T_1)\\
                m_2 \in NT(T_2)\\
                (m_1,m_2) \in L(n_1,n_2)\\
                PR(m_1) = PR(m_2)
        \end{array}
        \right\}  
      \end{equation}

    Количество пар узлов $C_{TO}(n_1,n_2)$, содержащихся в множесте $N_{TO}(n_1,n_2)$, определяет количество общих узлов при наложении дерева $T_1$ на дерево $T_2$ в узла $n_1$ и $n_2$ и определяется формулой \ref{eq:base_Cto}: 

      \begin{equation}
        \label{eq:base_Cto}
        C_{TO}(n_1,n_2) = | N_{TO}(n_1,n_2) |
      \end{equation}

    Для того, чтобы начать учитывать терминальные узлы, изменим часть условий для формирования множества $N_{TO}(n_1,n_2)$. В первую очередь, введем допущение, что $m_1$ и $m_2$ могут быть терминальными узлами. Пусть, если $NT(T)$ --- все узлы дерева $T$ за исключением терминальных, то $nodes(T)$ --- все узлы дерева $T$.

    Как известно, терминальные узлы не содержат дочерних узлов, ввиду этого у них нет правил перехода от них самих к дочерним узлам. Сделаем допущение: если узлы  $m_1$ и $m_2$ деревьев $T_1$ и $T_2$ являются терминальным и их названия совпадают, то их правила перехода также совпадают. После внесения изменений, базовая формула \ref{eq:base_Nto}, формирующая количество схожих пар узлов между деревьями при наложении их друг на друга в узлах $n_1$ и $n_2$ будет иметь вид:

      \begin{equation}
        \label{eq:new_Nto}
        N_{TO}^{'}(n_1,n_2) = 
        \left\{ (m_1,m_2) \,
        \begin{array}{|l}
                m_1 \in \boldsymbol{nodes}(T_1)\\
                m_2 \in \boldsymbol{nodes}(T_2)\\
                (m_1,m_2) \in L(n_1,n_2)\\
                \boldsymbol{PR}(m_1) = \boldsymbol{PR}(m_2)
        \end{array}
        \right\}  
      \end{equation}

      Подсчет количества общих узлов при наложении дерева $T_1$ на дерево $T_2$ в узла $n_1$ и $n_2$ в модифицированном алгоритме на этом этапе будет определятся схожим образом с формулой \ref{eq:base_Cto} и будет иметь вид: 

      \begin{equation}
        \label{eq:new_Cto}
        C_{TO}^{'}(n_1,n_2) = | N_{TO}(n_1,n_2) |
      \end{equation}


    Пример подсчета схожести формулой \ref{eq:base_Cto} базового алгоритма и формулой \ref{eq:new_Cto} модифицированного алгоритма показан на рис.~\ref{img:dif_Cto_termnodes}:

      \begin{figure}[ht] 
        \center
        \includegraphics[width=.95\linewidth]{img/tikzpictures/chapt_2/diff_termnodes}
        \caption{Пример подсчета схожести идентичных деревьев при их наложении в узлах $a_1$ и $a_2$ базовым алгоритмом (слева) и модифицированным (справа)}
        \label{img:dif_Cto_termnodes}
      \end{figure}


    На примере, представленном на рис.~\ref{img:dif_Cto_termnodes}, множества пар узлов $N_{TO}$ будут определятся:

    \begin{itemize}
      \item $N_{TO}(a_1,a_2) = \{(a^1,a^2), (b^1,b^2), (d^1,d^2)\}$
      \item $N^{'}_{TO}(a_1,a_2) = \{(a^1,a^2), (b^1,b^2), (d^1,d^2), (c^1,c^2), (e^1,e^2)\}$
    \end{itemize}
    \medskip
    
    Количества общих узлов между деревьями на рис.~\ref{img:dif_Cto_termnodes} будут равными:
    \begin{itemize}
    \item $C_{TO}(a_1,a_2) = |N_{TO}(a_1, a_2)| = 3$
    \item $C^{'}_{TO}(a_1,a_2) = |N^{'}_{TO}(a_1, a_2)| = 5$
    \end{itemize}
    \medskip


    Помимо схожести терминальных узлов, необходимо модифицировать алгоритм, чтобы он учитывал схожесть одинаковых узлов, которые имеют одно и то же значение и которые стоят в том же самом порядке относительно своих родственных узлов, но не имеющих одинакового правила перехода от себя к другим узлам. 

    Введем понятия множества $P(n_1, n_2)$, которое содержит набор пар узлов в виде пути, начиная от узлов $n_1$, $n_2$, и продолжая до самых последних одинаковых узлов, стоящих среди своих братьев и сестер в одном и том же порядковом номере, и для которых узлы $n_1$ и $n_2$ являются потомками. $P(n_1, n_2)$ формируется следующим образом:

      \begin{enumerate}
        \item $(n_1, n_2) \in P$
        \item Если $ch(parent(n_1),i) = ch(parent(n_2),i)$ \\
              \phantom{ } и $ch(parent(n_1),i) = n_1$ \\
              \phantom{ } и $ch(parent(n_2),i) = n_2$ \\
              \phantom{ } то $(parent(n_1), parent(n_2)) \in P$
        \item $P(n_1, n_2)$  включает в себя все пары узлов, сгенерированные рекурсивно пунктом номер~2.
      \end{enumerate}
      \medskip

    Введем понятие множества $P_{WPR}(n_1, n_2)$, которое определяется также, как и $P(n_1, n_2)$, с тем лишь исключением, что, если пара промежуточных узлов в пути содержит одно и то же правило перехода, то они в множество не заносятся. $P_{WPR}(n_1, n_2)$ формируется следующим образом:

      \begin{enumerate}
        \item $(n_1, n_2) \notin P_{WPR}$
        \item Если $PR(parent(n_1)) \neq PR(parent(n_2))$\\
              \phantom{ } и $ch(parent(n_1),i) = ch(parent(n_2),i)$\\
              \phantom{ } и $ch(parent(n_1),i) = n_1$ \\
              \phantom{ } и $ch(parent(n_2),i) = n_2$ \\
              \phantom{ } то $(parent(n_1), parent(n_2)) \in P_{WPR}$
        \item $P_{WPR}(n_1, n_2)$  включает в себя все пары узлов, сгенерированные рекурсивно пунктом номер~2.
      \end{enumerate}
      \medskip

    На рис.~\ref{img:P_sample} продемонстрирован пример формирования множества $P(n_1, n_2)$ и $P_{WPR}(n_1, n_2)$:

      \begin{figure}[ht] 
        \center
        \includegraphics[width=.98\linewidth]{img/tikzpictures/chapt_2/P_sample}
        \caption{Определение множеств $P(n_1, n_2)$ (слева) и $P_{WPR}(n_1, n_2)$ (справа) на примере узлов $g_1$ и $g_2$ деревьев $T_1$ и $T_2$}
        \label{img:P_sample}
      \end{figure}

    Как видно из рис.~\ref{img:P_sample}, множества $P$ и $P_{WPR}$ от узлов $g_1$ и $g_2$ будут равны:
      \begin{itemize}
        \item $P(g_1, g_2) = \{(g^1,g^2),(d^1,d^2), (c^1,c^2), (a^1,a^2)\}$
        \item $P_{WPR}(g_1, g_2) = \{(c^1,c^2), (a^1,a^2)\}$
      \end{itemize}
      \medskip
    
    $P_{WPR}(g_1, g_2)$ не содержит пару узлов $(d_1,d_2)$ из-за того, что узлы в ней имеют одинаковые правила перехода. По таким же рассуждениям пара узлов $(g_1,g_2)$ также не заносится в множество $P_{WPR}(g_1, g_2)$.
    
    Введем определение $top(n_1,n_2)$, обозначающее последнюю пару в множестве $P(n_1, n_2)$ или в множестве $P_{WPR}(n_1, n_2)$: 

    
      \begin{equation}
        \label{eq:top}
        top(n_1,n_2) = p_{last}(n_1, n_2) \textup{,\quad\quad} p_{last} \in P \lor P_{WPR}
      \end{equation}

     На рис.~\ref{img:P_sample} $top(g_1,g_2)$ будет определятся одинаково для $P(d_1, d_2)$ и для $P_{WPR}(d_1, d_2)$ и равняться в обоих случаях $top(d_1,d_2) = (a_1,a_2)$. 

     Введем формальное определение множества пар узлов в виде пути до узлов $m_1,m_2$, получившихся в результате наложения узла $n_1$ на узел $n_2$ деревьев $T_1$ и $T_2$: 


      \begin{equation}
        \label{eq:new_Pto}
        P_{TO}(n_1,n_2) = 
        \left\{ (m_1,m_2) \,
        \begin{array}{|l}
                (p_1,p_2) \in N_{TO}(n_1,n_2)\\
                (m_1,m_2) \in P_{WPR}(p_1,p_2),\\
                \phantom{XXX} \textup{если} \quad top(m_1,m_2) = (n_1,n_2)
        \end{array}
        \right\}  
      \end{equation}


    Окончательно преобразуем формулу подсчета схожести деревьев $T_1$ и $T_1$ при наложение узлов $n_1$ и $n_2$. С учетом формулы \ref{eq:new_Pto} формула $C_{TO}$ будет иметь вид: 

      \begin{equation}
        \label{eq:new_Cto2}
        C_{TO}^{''}(n_1,n_2) = |N^{'}_{TO}(n_1,n_2)| + |P_{TO}(n_1,n_2)|
      \end{equation}

   Пример подсчета схожести деревьев $T_0$ и $T_1$ в узлах $n_1$ и $n_2$ базовым и модифицированным алгоритмами приведен на рис.~\ref{img:diff_Cto}:
    
      \begin{figure}[ht] 
        \center
        \includegraphics[width=.98\linewidth]{img/tikzpictures/chapt_2/diff_Cto}
        \caption{Пример поиска схожести между деревьями $T_0$ и $T_1$ базовым алгоритмом (слева) и модифицированным алгоритмом (справа)} 
        \label{img:diff_Cto}  
      \end{figure}

  
    Формула схожести между деревом $T_1$ и $T_2$ после модификации определяется следующим образом:

        \begin{equation}
          \label{eq:new_Sto}
          S^{'}_{TO}(T_1, T_2) = \max_{n_1 \in nodes(T_1), n_2 \in nodes(T_2)} C^{''}_{TO} (n_1, n_2)
        \end{equation}
  

    В дальнейшем будут использоваться определения модифицированного алгоритма и для простоты восприятия формул $C^{''}_{TO} (n_1, n_2)$ и $S^{'}_{TO}(T_1, T_2)$ они будут цитироваться как $C_{TO} (n_1, n_2)$ и $S_{TO}(T_1, T_2)$ несмотря на то, что эти формулы соответствуют обозначениям формул базового алгоритма.


    Алгоритм создания таблицы индексов при поиске схожести дерева по корпусу деревьев также претерпел изменения. Теперь таблица индексов может содержать терминальные правила перехода с терминальными узлами. Элементы таблицы индексов определяются следующей формулой:

      \begin{equation}
        \label{eq:new_IdxTable}
        I[p] = 
        \left\{ (m) \,
        \begin{array}{|l}
                T \in F\\
                m \in \boldsymbol{nodes}(T)\\
                p = \boldsymbol{PR}(m)
        \end{array}
        \right\}  
      \end{equation}

    Приведем пример составления таблиц индексов для корпуса из деревьев $T_1$ и $T_2$ (рис.~\ref{img:IdxTbl_sample}) по базовому алгоритму (табл.~\ref{tbl:diff_idxTable_old}) и по модифицированному (табл.~\ref{tbl:diff_idxTable_new}):

      \begin{figure}[ht] 
        \center
        \includegraphics[width=.4\linewidth]{img/tikzpictures/chapt_2/samples_t1t2}
        \caption{Корпус из деревьев $T_1$ и $T_2$} 
        \label{img:IdxTbl_sample}  
      \end{figure}


        \begin{table} [htbp]%
          \parbox{.47\linewidth}{
              \centering
                  \caption{Таблица индексов $T_1,T_2$ (базовый алгоритм)}%
                  \label{tbl:diff_idxTable_old}
              \renewcommand{\arraystretch}{1.1}
              \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                    \toprule
                  $p$ & $I[p]$\\
                    \midrule 
                  $a \rightarrow b \, f$    & $a^1$\\
                  $b \rightarrow d \, e$    & $b^1$\\
                  $a \rightarrow b \, c$    & $a^2$\\
                  $b \rightarrow f \, g$    & $b^2$\\
                    \bottomrule
                  \\
                  \\
                  \\
                  \\
                  \\
              \end{tabular}%
          }
        \hfill
          \parbox{.47\linewidth}{
              \centering
                  \caption{Таблица индексов $T_1$,$T_2$ (модифицированный алгоритм)}
                  \label{tbl:diff_idxTable_new}
              \renewcommand{\arraystretch}{1.1}
              \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                    \toprule
                  $p$ & $I[p]$  \\
                    \midrule 
                  $a \rightarrow b \, f$    & $a^1$\\
                  $b \rightarrow d \, e$    & $b^1$\\
                  $f$                       & $f^1, f^2$\\
                  $d$                       & $d^1$\\
                  $e$                       & $e^1$\\
                  $a \rightarrow b \, c$    & $a^2$\\
                  $b \rightarrow f \, g$    & $b^2$\\
                  $c$                       & $c^2$\\
                  $g$                       & $g^2$\\
                    \bottomrule
              \end{tabular}%
            }
        \end{table}

    Как видно из табл.~\ref{tbl:diff_idxTable_old} и табл.~\ref{tbl:diff_idxTable_new}, они отличаются друг от друга лишь наличием <<пустых>> правил перехода и терминальных узлов в таблице индексов.

    В этом разделе, кроме вышеописанных, появляются некоторые дополнительные изменения при поиске схожести подвыражений. Эти изменения будут подробно описаны в разделе~\ref{chapt2_newAlgo__subexprSim}, посвященному поиску схожести подвыражений. 

    Далее, в подраздах~\ref{chapt2_newAlgo__structSim}~и~\ref{chapt2_newAlgo__subexprSim} будут приведены примеры нахождения структурной схожести и схожести подвыражений модифицированным алгоритмом.


  \section{Применение алгоритма при вычислении структурной схожести} \label{chapt2_newAlgo__structSim}


    Приведем пример поиска структурной схожести между деревом $T_0$ и корпусом деревьев $T_1$ и $T_2$ (рис.~\ref{img:samples_t0t1t2}). Для этого составим таблицу индексов (табл.~\ref{tbl:structSim_idxTable_t0}) для дерева $T_0$ и таблицу индексов (табл.~\ref{tbl:structSim_idxTable_t1t2}) для корпуса деревьев $T_1$ и $T_2$.


      \begin{figure}[ht] 
        \center
        \includegraphics[width=.7\linewidth]{img/tikzpictures/chapt_2/samples_t0t1t2}
        \caption{Запрашиваемое дерево $T_0$ и корпус из деревьев $T_1$ и $T_2$} 
        \label{img:samples_t0t1t2}  
      \end{figure}


        \begin{table} [htbp]%
          \parbox{.44\linewidth}{
              \centering
                  \caption{Таблица индексов $T_0$}%
                  \label{tbl:structSim_idxTable_t0}
              \renewcommand{\arraystretch}{1.1}
              \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                    \toprule
                  $p$ & $I[p]$\\
                    \midrule 
                  $a \rightarrow b \, c$    & $a^0$\\
                  $b \rightarrow d \, e$    & $b^0$\\
                  $c$                       & $c^0$\\
                  $d$                       & $d^0$\\
                  $e$                       & $e^0$\\
                    \bottomrule
                  \\
                  \\
                  \\
                  \\
              \end{tabular}%
          }
        \hfill
          \parbox{.48\linewidth}{
              \centering
                  \caption{Таблица индексов $T_1$,$T_2$}%
                  \label{tbl:structSim_idxTable_t1t2}
              \renewcommand{\arraystretch}{1.1}
              \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                    \toprule
                  $p$ & $I[p]$  \\
                    \midrule 
                  $a \rightarrow b \, f$    & $a^1$\\
                  $b \rightarrow d \, e$    & $b^1$\\
                  $f$                       & $f^1, f^2$\\
                  $d$                       & $d^1$\\
                  $e$                       & $e^1$\\
                  $a \rightarrow b \, c$    & $a^2$\\
                  $b \rightarrow f \, g$    & $b^2$\\
                  $c$                       & $c^2$\\
                  $g$                       & $g^2$\\
                    \bottomrule
              \end{tabular}%
            }
        \end{table}



    Табл.~\ref{tbl:structSim_idxTable_t0} и табл.~\ref{tbl:structSim_idxTable_t1t2} сформированы по формуле~\ref{eq:new_IdxTable}. Левый столбец $p$ содержит информацию о правиле перехода, который присутствует среди узлов деревьев корпуса, а правый столбец $I[p]$ информацию о том, какой узел содержит данное правило перехода. 
    По полученным таблицам индексов (табл.~\ref{tbl:structSim_idxTable_t0} и табл.~\ref{tbl:structSim_idxTable_t1t2}), составим табл.~\ref{tbl:structSim_top} между узлами дерева $T_0$ и деревьями корпуса $T_1$ и $T_2$.
    % описать, что она содержит

      \begin{table} [htbp]%
          \centering
        \caption{Таблица Top между узлами дерева $T_0$ и узлами деревьев $T_1$ и $T_2$}%
        \label{tbl:structSim_top}
          \renewcommand{\arraystretch}{1.1}
        \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
              \toprule
            $(n,m)$ & $top(n,m)$  \\
              \midrule
            $(a^0, a^2)$   & $(a^0, a^2)$ \\
            $(b^0, b^1)$   & $(a^0, a^1)$ \\
            $(c^0, c^2)$   & $(a^0, a^2)$ \\
            $(d^0, d^1)$   & $(a^0, a^1)$ \\
            $(e^0, e^1)$   & $(a^0, a^1)$ \\
              \bottomrule
        \end{tabular}%
      \end{table}


    У табл.~\ref{tbl:structSim_top} левый столбец $(n,m)$ содержит совпавшие узел дерева $T_0$ и узел дерева корпуса с одинаковыми правилами перехода. Правый столбец $top(n,m)$ содержит пару узлов, определенную формулой~\ref{eq:top}. 

    Подсчитываем количество одинаковых пар узлов из правого столбца табл.~\ref{tbl:structSim_top}, являющегося множеством, определенном по формуле \ref{eq:new_Nto} и получаем 
    $|N_{TO}(a_0, a_1)| = 3$,
    $|N_{TO}(a_0, a_2)| = 2$. 
    С учетом того, что пара узлов $(a_0, a_1)$ принадлежит множеству $P_{WPR}$, определенному ранее в разделе~\ref{chapt2_newAlgo__modif}, получаем $|P_{TO}(a_0, a_1)| = 1$.

    Согласно формуле~\ref{eq:new_Sto} схожесть между запрашиваемым деревом $T_0$ и деревом корпуса $T_1$ будет равна $S_{TO}(T_0, T_1) = 3+1=4$, а между запрашиваемым деревом $T_0$ и деревом корпуса $T_2$ равна $S_{TO}(T_0, T_2) = 2$. Схожесть между деревьями продемонстрирована на рис.~\ref{img:newAlgo_structSim_result}.

      \begin{figure}[ht] 
        \center
        \includegraphics[width=.99\linewidth]{img/tikzpictures/chapt_2/newAlgo_structSim_result}
        \caption{Структурная схожесть между деревьями $T_0$ и $T_1$ (слева) и между деревьями $T_0$ и $T_2$ (справа)} 
        \label{img:newAlgo_structSim_result}  
      \end{figure}


  \section{Применение алгоритма при вычислении схожести подвыражений} \label{chapt2_newAlgo__subexprSim}


    Приведем пример поиска схожести подвыражений между деревом $T_0$ и корпусом из деревьев $T_1$ и $T_2$ (рис.~\ref{img:samples_subExprSim_t1t2t3}). Для этого составим таблицу индексов (табл.~\ref{tbl:subexprSim_idxTable_t0}) для дерева $T_0$ и таблицу индексов (табл.~\ref{tbl:subexprSim_idxTable_t1t2}) для корпуса $T_1$ и $T_2$.


      \begin{figure}[ht] 
        \center
        \includegraphics[width=.74\linewidth]{img/tikzpictures/chapt_2/samples_subExprSim_t1t2t3}
        \caption{Запрашиваемое дерево $T_0$ и корпус из деревьев $T_1$ и $T_2$} 
        \label{img:samples_subExprSim_t1t2t3}  
      \end{figure}



        \begin{table} [htbp]%
          \parbox{.44\linewidth}{
              \centering
                  \caption{Таблица индексов $T_0$}%
                  \label{tbl:subexprSim_idxTable_t0}
              \renewcommand{\arraystretch}{1.1}
              \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                    \toprule
                  $p$ & $I[p]$\\
                    \midrule 
                  $a \rightarrow b \, c \, f$   & $a^0$\\
                  $b \rightarrow c \, d$        & $b^0$\\
                  $e$                           & $e^0$\\
                  $f$                           & $f^0$\\
                  $c$                           & $c^0$\\
                  $d$                           & $d^0$\\
                    \bottomrule
                  \\
                  \\
              \end{tabular}%
          }
        \hfill
          \parbox{.48\linewidth}{
              \centering
                  \caption{Таблица индексов $T_1$,$T_2$}%
                  \label{tbl:subexprSim_idxTable_t1t2}
              \renewcommand{\arraystretch}{1.1}
              \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                    \toprule
                  $p$ & $I[p]$  \\
                    \midrule 
                  $g \rightarrow a$         & $g^1$\\
                  $a \rightarrow b \, e$    & $a^1$\\
                  $b \rightarrow c \, d$    & $b^1, b^2$\\
                  $e$                       & $e^1$\\
                  $c$                       & $c^1, c^2$\\
                  $d$                       & $d^1, d^2$\\
                  $h \rightarrow b $        & $h^2$\\
                  $b \rightarrow f \, g$    & $b^2$\\
                    \bottomrule
              \end{tabular}%
            }
        \end{table}


    Табл.~\ref{tbl:subexprSim_idxTable_t0} и табл.~\ref{tbl:subexprSim_idxTable_t1t2} сформированы по формуле~\ref{eq:new_IdxTable}. Левый столбец $p$ содержит информацию о правиле перехода, который присутствует среди узлов деревьев корпуса, а правый столбец $I[p]$ информацию о том, какой узел содержит данное правило перехода. 
    По полученным таблицам индексов (табл.~\ref{tbl:subexprSim_idxTable_t0} и табл.~\ref{tbl:subexprSim_idxTable_t1t2}), составим табл.~\ref{tbl:subexprSim_top} между узлами дерева $T_0$ и деревьями корпуса $T_1$ и $T_2$.
    
      \begin{table} [htbp]%
          \centering
        \caption{Таблица Top между узлами дерева $T_0$ и узлами деревьев $T_1$ и $T_2$}%
        \label{tbl:subexprSim_top}
          \renewcommand{\arraystretch}{1.1}
        \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
              \toprule
            $(n,m)$ & $top(n,m)$ \\
              \midrule
            $(b^0, b^1)$   & $(a^0, a^1)$ \\
            $(b^0, b^2)$   & $(b^0, b^2)$ \\
            $(e^0, e^1)$   & $(a^0, a^1)$ \\
            $(c^0, c^1)$   & $(a^0, a^1)$ \\
            $(c^0, c^2)$   & $(b^0, b^2)$ \\
            $(d^0, d^1)$   & $(a^0, a^1)$ \\
            $(d^0, d^2)$   & $(b^0, b^2)$ \\
              \bottomrule
        \end{tabular}%
      \end{table}

    У табл.~\ref{tbl:subexprSim_top} левый столбец $(n,m)$ содержит совпавшие узел дерева $T_0$ и узел дерева корпуса с одинаковыми правилами перехода. Правый столбец $top(n,m)$ содержит пару узлов, определенную формулой~\ref{eq:top}. Далее, подсчитываем количества одинаковых пар узлов из правого столбца табл.~\ref{tbl:structSim_top}, являющегося множеством, определенном по формуле~\ref{eq:new_Nto} и получаем:
    \begin{itemize}
      \item $|N_{TO}(a_0, a_1)| = 4$
      \item $|N_{TO}(b_0, b_2)| = 3$
    \end{itemize}


    С учетом того, что пара узлов $(a_0, a_1)$ принадлежит множеству $P_{WPR}$, определенному ранее в разделе \ref{chapt2_newAlgo__modif}, то $|P_{TO}(a_0, a_1)| = 1$.

    Схожести, полученные в результате наложения дерева $T_0$ на деревья корпуса $T_1$ и $T_2$ в узла $a_0$, $a_1$ и $b_0$, $b_2$ определяются формулой~\ref{eq:new_Cto2} и равны:
    \begin{itemize}
      \item $C{TO}(a_0,a_1) = |N_{TO}(a_0, a_1)| + |P_{TO}(a_0, a_1)| = 5$
      \item $C{TO}(b_0,b_2) = |N_{TO}(a_0, a_1)| = 3$
    \end{itemize}
    

    Далее необходимо узнать, являются ли полученные схожие области поддеревьями.
    При наложении узлов $n_1$ и $n_2$ друг на друга, мы будем считать, что, в случае, если полученная область является поддеревом, то она должна содержать количество листьев равное большему из двух количеств листьев поддеревьев, образованных отдельно от узлов $n_1$ и $n_2$.

    К примеру, на рис.~\ref{img:samples_subExprSim_t1t2t3} поддерево дерева $T_0$, образованное от узла $a_0$ содержит 4 терминальных узла, а поддерево $T_1$, образованное от узла $a_1$ содержит 3 терминальных узла. При наложении деревьев в узлах $a_0$ и $a_1$, количество листьев, которое должно быть покрыто <<потенциальным получившимся поддеревом>> равно $\max \{3,4\} = 4$. 

    Введем понятие $Leaves_{cover}(n_1,n_2)$, которое будет содержать два числа --- первое будет определять, какое общее количество листьев покроется при наложении узлов $n_1$, $n_2$ друг на друга, а второе будет показывать сколько необходимо покрыть листьев, чтобы полученная при таком наложении область была поддеревом.

    Для нашего рассматриваемого примера, еще раз пройдем таблицу Top (табл.~\ref{tbl:subexprSim_top}) и просмотрим наличие терминальных пар узлов из левого столбца у узлов $(n_1,n_2)$ из правого, и если они терминальные, прибавим к значению $Leaves_{cover}(n_1,n_2)$ единицу. Получим следующие значения:
    \begin{itemize}
      \item $Leaves_{cover}(a_0,a_1) = 3 / 4$
      \item $Leaves_{cover}(b_0,b_2) = 3 / 3$
    \end{itemize}
    \medskip
    
    Можно сказать, что область, полученная при наложении узлов $a_0$ и $a_1$ не является поддеревом, а область, полученная при наложении $b_0$ и $b_2$ --- является. Это продемонстрировано на рис.~\ref{img:subExprSim_tempRes}.

      \begin{figure}[ht] 
        \center
        \includegraphics[width=\linewidth]{img/tikzpictures/chapt_2/subExprSim_tempRes}
        \caption{Схожесть между деревьями $T_0$ и узлами корпуса в узлах $a_0, a_1$ и $b_0, b_2$} 
        \label{img:subExprSim_tempRes}  
      \end{figure}

    На рис.~\ref{img:subExprSim_tempRes} видно, что схожесть между деревьями $T_0$ и $T_2$ в узлах $b_0, b_2$ полностью покрыта поддеревом, в то время как схожесть между $T_0$ и $T_1$ в узлах $a_0, a_1$ нет. 
    На текущем этапе задача по поиску схожести подвыражений между деревьями $T_0$ и $T_1$ не решена. Из-за этого  необходимо еще раз повторить алгоритм нахождения схожести, преобразовав деревья $T_0$ и $T_1$ к деревьям $T_0^{'}$ и $T_1^{'}$, которые будут отличатся вычеркнутыми узлами, которые при наложении не покрыли все поддерево. Кроме этого, вычеркиваются и все вышележащие относительно них узлы. Преобразование деревьев $T_0$, $T_1$ к $T_0^{'}$ и $T_1^{'}$ продемонстрировано на рис.~\ref{img:subExprSim_new_t0t1}.


      \begin{figure}[ht] 
        \center
        \includegraphics[width=\linewidth]{img/tikzpictures/chapt_2/subExprSim_new_t0t1}
        \caption{Переход от деревьев $T_0$, $T_1$ к $T_0^{'}$, $T_1^{'}$ методом вычеркивания $a_0$, $a_1$ и всех вышележащих отнотилеьно них узлов} 
        \label{img:subExprSim_new_t0t1}  
      \end{figure}


    Еще раз составим таблицу индексов, но теперь уже только для дерева $T_0^{'}$ (табл.~\ref{tbl:subexprSim_idxTable_t0s}) и $T_1^{'}$ (табл.~\ref{tbl:subexprSim_idxTable_t1s}):


        \begin{table} [htbp]%
          \parbox{.44\linewidth}{
              \centering
                  \caption{Таблица индексов $T_0^{'}$}%
                  \label{tbl:subexprSim_idxTable_t0s}
              \renewcommand{\arraystretch}{1.1}
              \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                    \toprule
                  $p$ & $I[p]$\\
                    \midrule 
                  $b \rightarrow c \, d$        & $b^0$\\
                  $e$                           & $e^0$\\
                  $f$                           & $f^0$\\
                  $c$                           & $c^0$\\
                  $d$                           & $d^0$\\
                    \bottomrule
              \end{tabular}%
          }
        \hfill
          \parbox{.48\linewidth}{
              \centering
                  \caption{Таблица индексов $T_1^{'}$}%
                  \label{tbl:subexprSim_idxTable_t1s}
              \renewcommand{\arraystretch}{1.1}
              \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                    \toprule
                  $p$ & $I[p]$  \\
                    \midrule 
                  $b \rightarrow c \, d$    & $b^1$\\
                  $e$                       & $e^1$\\
                  $c$                       & $c^1$\\
                  $d$                       & $d^1$\\
                    \bottomrule
                    \\
              \end{tabular}%
            }
        \end{table}


      \begin{table} [htbp]%
          \centering
        \caption{Таблица Top между узлами дерева $T_0^{'}$ и узлами дерева $T_1^{'}$}%
        \label{tbl:subexprSim_reqtop}
          \renewcommand{\arraystretch}{1.1}
        \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
              \toprule
            $(n,m)$ & $top(n,m)$ \\
              \midrule
            $(b^0, b^1)$   & $(b^0, b^1)$ \\
            $(e^0, e^1)$   & $(e^0, e^1)$ \\
            $(c^0, c^1)$   & $(b^0, b^1)$ \\
            $(d^0, d^1)$   & $(b^0, b^1)$ \\
              \bottomrule
        \end{tabular}%
      \end{table}

    По табл.\ref{tbl:subexprSim_reqtop} подсчитываем количество одинаковых пар узлов из правого столбца и получаем:
      \begin{itemize}
        \item $|N_{TO}(b_0, b_1)| = 3$
        \item $|N_{TO}(e_0, e_1)| = 1$
      \end{itemize}
      \medskip

    В результате наложения дерева $T_0^{'}$ на дерево $T_1^{'}$ в узлах $b_0,b_1$ и $e_0,e_1$ схожести будут равны:
      \begin{itemize}
        \item $C{TO}(b_0, b_1) = |N_{TO}(b_0, b_1)| = 3$
        \item $C{TO}(e_0, e_1) = |N_{TO}(e_0, e_1)| = 1$
      \end{itemize}
      \medskip


    Подсчитываем количество листьев, которые покрыли области при наложении узлов $b_0, b_1$ и $e_0, e_1$:
      \begin{itemize}
        \item $Leaves_{cover}(b_0,b_1) = 2/2$
        \item $Leaves_{cover}(e_0,e_1) = 1/1$
      \end{itemize}
      \medskip

    Поскольку в обоих случаях были покрыты все листья, то обе области, полученные в результате наложения $b_0,b_1$ и $e_0,e_1$, являются поддеревьями и нам подходят. В случае, если бы это было не так, нам бы пришлось еще раз переходить от рассмотрения деревьев $T_0^{'}$ и $T_1^{'}$ к последующим, и так до тех пор, пока все области, полученные при дальнейшем наложении друг на друга в одинаковых узлах не стали бы являться поддеревьями.

    Вернемся к исходной задаче и подсчитаем все схожести, полученные при наложении одинаковых узлов между запрашиваемым деревом $T_0$ и деревьями корпуса $T_1$ и $T_2$, которые покрыты поддеревом:
      \begin{itemize}
        \item $C{TO}(b_0, b_2) = 3$
        \item $C{TO}(b_0, b_1) = 3$
        \item $C{TO}(e_0, e_1) = 1$
      \end{itemize}
      \medskip

    Согласно формуле \ref{eq:new_Sto} схожесть между запрашиваемым деревом $T_0$ и деревом корпуса $T_1$ будет равна $S_{TO}(T_0, T_1) = 3$, а между запрашиваемым деревом $T_0$ и деревом корпуса $T_2$ также равна $S_{TO}(T_0, T_2) = 3$. Схожесть между деревьями продемонстрирована на рис.~\ref{img:subExprSim_Res}.

      \begin{figure}[ht] 
        \center
        \includegraphics[width=\linewidth]{img/tikzpictures/chapt_2/subExprSim_Res}
        \caption{Схожесть подвыражений между деревьями $T_0$ и $T_1$ (слева) и между деревьями $T_0$ и $T_2$ (справа)} 
        \label{img:subExprSim_Res}  
      \end{figure}














 


 
 
 















