\chapter{Описание приложения, реализующего поиск синтаксически схожих математических выражений на основе разработанного алгоритма} \label{chapt3}

  С целью демонстрации поиска и тестирования математических выражений модифицированным алгоритмом было разработано приложение--прототип, которое реализует следующие заявленные функциональные требования:

    \begin{itemize}
      \item возможность парсинга математических выражений в формате MathML;
      \item хранение древовидных представлений математических выражений в базе;
      \item реализация поиска схожих математических выражений из базы заданному математическому выражению;
      \begin{enumerate}
        \item на основе структурной схожести;
        \item на основе схожести подвыражений;
      \end{enumerate}
      \item возможность визуального представления полученных результатов.
    \end{itemize}
  
  Для реализации было решено выбрать язык Java в связи с наличием библиотеки по визуализации выражений в формате MathML, а также опытом разработки программ на этом языке. В качестве среды разработки была выбрана IDE Netbeans.


  На рис.~\ref{img:UML} приведена диаграмма основных классов разработанного приложения. Для большей наглядности на диаграмме отражены только основные методы классов. Описание разработанных классов будет приведено в последующих параграфах.


      \begin{sidewaysfigure}
        \center
        \includegraphics[width=.98\linewidth]{img/uml/UML}
        \caption{Диаграмма UML основных классов приложения (часть методов опущена для большей наглядности)}
        \label{img:UML}
      \end{sidewaysfigure}



  \section{Генерация MathML выражений и их обработка}

    Все файлы с математическими выражениями в формате MathML хранятся отдельно в каждом файле с расширением <<.xml>>. Их генерация производилась путем написания необходимых выражений в формате \LaTeX\ и дальнейшей их конвертации с помощью конвертера \cite{mathmlconverter}.

    Для парсинга файлов с математическими выражениями используется соответствующий метод класса MathMLParserSupport из сторонней библиотеки net.sourceforge.jeuclid. Полученный объект класса Document принимается параметром для метода, который генерирует объект разработанного класса MathMLTree для последующей работы с древовидным представлением выражения. Ниже приведен фрагмент кода, иллюстрирующий данный порядок действий:

      \begin{lstlisting}[style={java}, autogobble=true]
          // загружаем xml файл  
          File f = new File(path, fileName);

          // парсим файл 
          Document domDocument = MathMLParserSupport.parseFile(f);

          // получаем объект для работы с древовидным представление выражения
          this.mathMLTree = MathMLTree.fromNode(domDocument.getDocumentElement());
      \end{lstlisting}

    Поскольку данное приложение носит цель демонстрации алгоритма, все данные о математических выражениях находятся отдельно в каждом файле, а не в базе данных. Они загружаются и обрабатываются данным фрагментом кода каждый раз во время исполнения программы.


  \section{Сущностные классы}

    \subsection{Класс, отвечающий за хранение и работу с древовидным представлениям выражения}

      Для хранения древовидных представлений выражений был разработан класс MathMLTree (прилож.~\ref{listings:MathMLTree}), который наследовал реализацию класса DefaultMutableTreeNode, определенного в пакете javax.swing.tree.TreeNode, который 
      содержит в себе два основных поля: объекта родителя и список объектов дочерних узлов, принадлежащих тому же самому классу, и ряд методов для работы с узлами.

      Решение наследоваться было принято ввиду наличия всех основных методов, необходимых для работы с древовидным представлением объекта. Из них можно выделить следующие:
        \begin{itemize}
          \item \textbf{public int getChildCount()} : возвращает количество дочерних узлов;
          \item \textbf{public boolean isRoot()} : определяет, является ли данный узел корневым, т.е. не имеет вышележащих узлов;
          \item \textbf{public Enumeration breadthFirstEnumeration()}: возвращает список узлов в порядке обхода узлов дерева в ширину (рис.~\ref{img:treeSearchTypes});
          \item \textbf{public Enumeration depthFirstEnumeration()}: возвращает список узлов в порядке обхода узлов дерева в глубину (рис.~\ref{img:treeSearchTypes});

            \begin{figure}[ht] 
                \center
                \includegraphics[width=.58\linewidth]{img/tikzpictures/chapt_3/treeSearchTypes}
                \caption{Пример обхода дерева в ширину (слева) и в глубину (справа)} 
                \label{img:treeSearchTypes}  
            \end{figure}

          \item \textbf{public int getSiblingCount()} : возвращает количество дочерних узлов от родителя текущего узла;
          \item \textbf{public DefaultMutableTreeNode getNextSibling()} : выдает следующего узла--родственника по списку;
          \item \textbf{public boolean isLeaf()}: определяется, имеет ли данный узел дочерние узлы или нет.
        \end{itemize}

      Кроме вышеперечисленных методов, унаследованных от класса DefaultMutableTreeNode, были также добавлены поле--идентификатор узла и следующие основные методы:

        \begin{itemize}
          \item \textbf{public static MathMLTree fromNode(Node node)}: возвращает дерево выражения из древовидной структуры узла типа Node (получаемой после парсинга xml документа);
          \item \textbf{public static MathMLTree fromString(String s)}: возвращает дерево выражения из строки (данный метод использовался для генерации тестовых деревьев);
          \item \textbf{public void normilizeTree()}: нормализует дерево выражения, обезличивая (замена на обобщающие названия) необходимые узлы;
          \item \textbf{public int getSiblingsNumber()}: возвращает количество дочерних узлов от родителя текущего узла;
          \item \textbf{public int getLabelIdxTime()}: возвращает каким по счету встретился этот узел среди узлов с таким же названием от корня дерева при обходе дерева в ширину;
          \item \textbf{public int getNodeBreadthOrder()}: возвращает номер узла при обходе дерева в ширину, начиная от корневого узла.
          \item \textbf{public TreeNode getNodeByBreadthOrderIndex(int n)}: возвращает узел под номером n при обходе поддерева в ширину, начинающегося от текущего узла.
        \end{itemize}


      Представленные методы были добавлены для последующего их использования в ходе поиска необходимой информации в древовидных представлениях выражений во время поиска их схожести по разработанному алгоритму.

  \subsection{Классы, отвечающие за составление таблиц индексации деревьев выражений}

    Для хранения дополнительной информации об узлах был разработан класс IdxNode (прилож.~\ref{listings:IdxNode}). Класс содержит такие поля как:
    \begin{itemize}
      \item идентификатор узла (название)
      \item идентификатор дерева, в котором находится данный узел
      \item каким по счету встречается узел с тем же идентификатором в дереве
      \item количество листьев у узла
      \item позиция в дереве при обходе в ширину.
    \end{itemize}

    Кроме этого был разработан метод для гибкой оценки равенства объектов данного класса. В зависимости от параметра, объекты признаются равными, если совпадают все поля объектов или же некоторая часть из них.

    Для хранения правил перехода от одного узла к последующим был разработан класс ProductionRule (прилож.~\ref{listings:ProductionRule}). При этом важно отметить, что данный класс содержит лишь информацию об идентификаторе (названии) узлов и не привязывается к конкретным узлам в дереве.

    Для связывания информации между правилами перехода и узлами, которые содержат данное правило, был разработан класс PRwithIdxNodes (прилож.~\ref{listings:PRwithIdxNodes}), который агрегирует в себя объект класса ProductionRule и список объектов IdxNode.

    С помощью классов, описанных в данном параграфе составляются таблицы индексов (список из правил перехода, каждый из которых содержит набор узлов с данным правилом перехода) для узлов математических выражений в древовидном представлении.



    \subsection{Класс, реализующий поиск схожести по разработанному алгоритму}

      Для реализации поиска структурной схожести и схожести подвыражений был разработан класс SearchEngine (прилож.~\ref{listings:SearchEngine}).

      Ниже приведены поля класса с их описанием:
      \begin{itemize}
        \item \textbf{MathMLTree qTr}: дерево выражения, для которого будет производиться поиск схожести;
        \item \textbf{List<MathMLTree> cTrs}: список из корпуса деревьев выражений, по которым будет производиться поиск;
        \item \textbf{List<PRwithIdxNodes> qIdxTb}: таблица индексов для запрашиваемого дерева;
        \item \textbf{List<PRwithIdxNodes> cIdxTb}: таблица индексов для корпуса деревьев;
        \item \textbf{ArrayList<Sto> stoList}: список объектов, содержащих информацию о схожести между запрашиваемым деревом \textit{qTr} и каждым деревом корпуса \textit{cTrs}.
      \end{itemize}

      Ниже приведены основные методы данного класса с их описанием:

        \begin{itemize}
          \item \textbf{public void setQueryTree(MathMLTree qTr)}: задаем дерево выражения, для которого будет производится поиск схожести (во время выполнения метода данное дерево индексируется для заполнения таблицы индексов запрашиваемого дерева \textit{qIdxTb});

          \item \textbf{public void addCorpusTree(MathMLTree cTr)}: добавляем дерево выражения в корпус, по которому будет производиться поиск (во время выполнения метода данное дерево индексируется для дополнения информации к таблице индексов корпуса \textit{cIdxTb});

          \item \textbf{public void calculateStructuralSimilarity()}: производится подсчет схожести подвыражений между запрашиваемым деревом \textit{qTr} и каждым деревом корпуса \textit{cTrs} (алгоритм подробно изложен в подразделе \ref{chapt2_newAlgo__structSim}), результат заносится в \textit{stoList};

          \item \textbf{public void calculateSubExprSimilarity()}: производится подсчет структурной схожести между запрашиваемым деревом \textit{qTr} и каждым деревом корпуса \textit{cTrs} (алгоритм подробно изложен в подразделе \ref{chapt2_newAlgo__subexprSim}), результат заносится в \textit{stoList};
        \end{itemize}


        В следующем фрагменте кода приведен пример использования объекта данного класса для подсчета одного из видов схожести между выражениями, хранимыми в файлах, представленных в формате MathML:

        \begin{lstlisting}[style={java}, autogobble=true]
          MathExpression expr1 = new MathExpression(PATH_TO_MATHML_DATABASE, "expr1.xml");
          MathExpression expr2 = new MathExpression(PATH_TO_MATHML_DATABASE, "expr2.xml");
          MathExpression expr3 = new MathExpression(PATH_TO_MATHML_DATABASE, "expr3.xml");
          
          SearchEngine se = new SearchEngine();
          se.setQueryTree(expr1.getMathMLTree());
          se.addCorpusTree(expr2.getMathMLTree());
          se.addCorpusTree(expr3.getMathMLTree());

          se.calculateSubExprSimilarity();
        \end{lstlisting}




    \subsection{Класс, хранящий информацию о схожести между выражениями}

      Для хранения информации о схожести между древовидными представлениями математических выражений, был разработан класс Sto (прилож.~\ref{listings:Sto}). Класс содержит:

        \begin{itemize}
          \item ссылки на объекты сравниваемых деревьев выражений;
          \item вид схожести между деревьями выражений;
          \item общую область из узлов, определяющую схожесть между деревьями выражений.
        \end{itemize}
       
      С помощью объекта данного класса можно получить информацию о количестве схожих узлов между деревьями, о месте начала схожести и т.п.



  \section{Визуальное представление результатов}

    Для настройки параметров поиска и представления результатов была использована библиотека Swing для создания графического интерфейса. На рис.~\ref{img:GUI_settings} и рис.~\ref{img:GUI_result} приведены окна графического интерфейса, отвечающие за установку параметров поиска и вывод результатов.

      \begin{figure}[ht] 
        \center
        \includegraphics[width=.72\linewidth]{img/showResults_GUI_1}
        \caption{Установка параметров поиска в графическом интерфейсе (SettingsFrame)} 
        \label{img:GUI_settings}  
      \end{figure}

      \begin{figure}[ht] 
        \center
        \includegraphics[width=.85\linewidth]{img/showResults_GUI_2}
        \caption{Вывод результата поиска схожести заданному выражению в графическом интерфейсе (ResultFrame)} 
        \label{img:GUI_result}  
      \end{figure}

    Для отображения математических выражений используется библиотека net.sourceforge.jeuclid, которая содержит класс, отвечающий за отображение математического выражения средствами Swing (javax.swing.JComponent).
    
      \begin{figure}[ht] 
        \center
        \includegraphics[width=.43\linewidth]{img/showResults_console}
        \caption{Консольный вывод результата поиска схожести заданному выражению} 
        \label{img:console_result}  
      \end{figure}


    Графический интерфейс, предоставляет не всю информацию относительно результатов поиска --- он показывает лишь пять выражений, оказавшихся самыми схожими с заданным. Ввиду этого, кроме графического интерфейса, также присутствует возможность консольного вывода информации. На рис.~\ref{img:console_result} приведен пример консольного вывода информации относительно схожести каждого уравнения из базы с заданным после поиска схожести подвыражений между ними.
    


    Данные способы визуального представления результатов поиска позволяют полноценно протестировать эффективность алгоритма. Тестирование алгоритма и оценка его эффективности будет произведена в разделе \ref{chapt4}.




















