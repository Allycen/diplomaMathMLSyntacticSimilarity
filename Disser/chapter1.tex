\chapter{Исследование предметной области} \label{chapt1}


  \section{Описание структуры математических выражений в формате MathML} \label{chapt1__mathml}


    MathML (Mathematical Markup Language)---  это язык разметки на основе XML для представления математических символов и формул. Логическая структура документа схожа с логической структурой документа XML: он имеет обязательный корневой элемент, включающий в себя вложенные в него один или несколько элементов. Граница элемента определяется знаками $<$ и $>$. Элемент может содержать тег, определяющий имя элемента, а также один или несколько атрибутов и данные элемента.

    Существует два вида разметки MathML ---- Presentation Markup и Content Markup. Каждый имеет свой набор возможных элементов и разный принцип их вложения друг в друга. Для того, чтобы лучше понять, какой из видов разметки использовать, рассмотрим их подробнее в следующих разделах на основе документации \cite{mathml_documentation} по MathML.
    
    

    \subsection{Разметка Presentation Markup} \label{chapt1__mathml__presentation_markup}

      Разметка Presentation Markup предназначена, чтобы описать визуальное представление выражения без учета его семантики. Этот вид разметки имеет небольшое фиксированное количество тегов, каждый из которых, в большинстве случаев, отвечает за конкретный структурный элемент в выражении, к примеру, операции деления или арифметического квадратного корня. Каждый элемент имеет фиксированное или нет количество обязательных элементов, которые он должен содержать, к примеру, элемент, отвечающий за представление арифметического квадратного корня, должен содержать в себе элемент, отвечающий за выражение, которое будет находится под корнем. Элементы условно можно разделить на 4 группы, отвечающих за: 
      лексемы (табл.~\ref{tbl:presentation_markup__elements_token}), 
      общую разметку выражений, визуально влияющих на синтаксическую структуру выражений (табл.~\ref{tbl:presentation_markup__elements_general1}) и нет (табл.~\ref{tbl:presentation_markup__elements_general2}), 
      представление выражений с индексами (табл.~\ref{tbl:presentation_markup__elements_scripts}), 
      представление выражений в виде таблиц и матриц (табл.~\ref{tbl:presentation_markup__elements_tables}). 


        \begin{table} [htbp]
          \centering
          %\parbox{15cm}{
          \caption{Элементы для отображения лексем}\label{tbl:presentation_markup__elements_token}
          %}
          \begin{tabular}{| p{2.0cm} | p{4.4cm}l |}
            \hline
            \centering Элемент &\centering Описание & \\
            \hline
            mi            & Переменная                                   & \\
            \hline
            mn            & Число                                        & \\
            \hline
            mo            & Оператор, специальный символ, разделитель    & \\
            \hline
            mtext         & Текст                                        & \\
            \hline
            mspace        & Пробел                                       & \\
            \hline
            mglyph        & Отображение символов без Unicode             & \\
            \hline
          \end{tabular}
        \end{table}


        \begin{table} [htbp]
          \centering
          \caption{Элементы для общей разметки выражений, визуально влияющие на синтаксическую структуру выражения
          \label{tbl:presentation_markup__elements_general1}}
          \begin{tabular}{| p{1.8cm} | p{5.5cm}  | p{1.5cm}l |}
            \hline
            \centering Элемент &\centering Описание &\centering Кол--во аргументов & \\
            \hline
            mrow          & Группир. подвыражений между собой                  &\centering 0+ &\\
            \hline
            mfrac         & Деление одного выражение на другое                &\centering 2 &\\
            \hline
            msqrt         & Извлечение из выражения квадратичного корня      &\centering 1 &\\
            \hline
            mroot         & Извлечение из выражения корня из n-ой степени    &\centering 2 &\\
            \hline
            mfenced       & При перечислении множества или массива, возможность добавления пользовательских открывыющих/ закрывающих скобок и разделителя                     &\centering 0+ &\\ 
            \hline
          \end{tabular}
        \end{table}


        \begin{table} [htbp]
          \centering
          \caption{Элементы для общей разметки выражений, визуально не влияющие на синтаксическую структуру выражения
          \label{tbl:presentation_markup__elements_general2}}
          \begin{tabular}{| p{1.8cm} | p{5.5cm}  | p{1.5cm}l |}
            \hline
            \centering Элемент &\centering Описание &\centering Кол--во аргументов & \\
            \hline
            mstyle        & Отвечает за стиль отображаемого выражения               & 1* & \\
            \hline
            merror        & Вывод сообщений об ошибке в мат. выражении              & 1* & \\
            \hline
            mpadded       & Отступы между элементами в выражении                    & 1* & \\
            \hline
            mphantom      & Скрытие элементы при отображении, но занимающие место   & 1*  &\\
            \hline
            menclose      & Помещает выражение в рамки                              & 1* & \\
            \hline
            maction       & Реакция на нажатие отображаемого элемента               & 1+ & \\
            \hline
          \end{tabular}
        \end{table}


        \begin{table} [htbp]
          \centering
          \caption{Элементы для отображения выражений с индексами}
          \label{tbl:presentation_markup__elements_scripts}
          \begin{tabular}{| p{1.8cm} | p{5.5cm}  | p{1.5cm}l |}
            \hline
            \centering Элемент &\centering Описание &\centering Кол--во аргументов & \\
            \hline
            msub          & Выражение с подстрочным индексом                  &\centering 2 &\\
            \hline
            msup          & Выражение с надстрочным индексом                  &\centering 2 &\\
            \hline
            msubsup       & Выражение с подстрочным и надстрочным индексом    &\centering 3 &\\
            \hline
            munder        & Нижняя фигурная скобка под выражением             &\centering 2 &\\
            \hline
            mover         & Верхняя фигурная скобка над выражением            &\centering 2 &\\
            \hline
            munderover    & Интегральная кривая с нижним и верхним пределом   &\centering 3 &\\
            \hline
            mmultiscripts & Позволяет создавать 4 индекса в виде матрицы вокруг выражения  &\centering 1+ &\\ 
            \hline
          \end{tabular}
        \end{table}


       \begin{table} [htbp]
          \centering
          \caption{Элементы для представления выражений в виде таблиц и матриц}
          \label{tbl:presentation_markup__elements_tables}
          \begin{tabular}{| p{1.8cm} | p{5.5cm}  | p{1.5cm}l |}
            \hline
            \centering Элемент &\centering Описание &\centering Кол--во аргументов &\\
            \hline
            mtable        & Таблица из n-го количества рядов                  &\centering 0+ &\\
            \hline
            mlabeledtr    & Ряд с заглавным элементом                         &\centering 1+ &\\
            \hline
            mtr           & Ряд в матрице                                     &\centering 0+ &\\
            \hline
            mtd           & Элемент в ряду                                    &\centering 1* &\\
            \hline
          \end{tabular}
        \end{table}



      Основное назначение аттрибутов в Presentation Markup --- задания параметров отображения элементов в выражении, таких как цвет, размер и задний фон. В силу того, что они не влияют на синтаксическую структуру выражения, рассматриваться подробнее они не будут.

      Отдельно стоит отметить, что для Presentation Markup не предусмотрены отдельные элементы, отвечающие за отображение функций как, к примеру, $sin, cos, tg, ctg, ln$ и т.п.

    \subsection{Разметка Content Markup} \label{chapt1__mathml__content_markup}

      Разметка Presentation Markup описывает математическое выражение без учёта его семантики. Разметка Content Markup разработана для того, чтобы помимо описания структуры выражения, иметь возможность описать его семантику. Во многих математических нотациях отображение одной и той же формулы может трактоваться по разному, и без дополнительной информации невозможно принять решение, как именно трактовать конкретное отображение примера. Трудности возникают из--за того, что разным представлениям математической нотации может соответствовать одна и та же семантика и наоборот. К примеру, конструкция <<$M$ перемножается с $g$>> может быть в одном контексте представлена как <<$M \times g$>>, а в другом <<$M g$>>. В последнем случае, отрывая от контекста этот пример, будет невозможно принять решение, является ли это, к примеру, именем химического элемента или изначально задуманной конструкцией.


      Чтобы решить эту проблему, с помощью разметки Сontent Markup устанавливается связь между математической структурой выражения или переменной и их семантикой. Каждой математической структуре соответствует базовая семантика, которая может быть изменена. К примеру, чтобы изменить семантику переменной $v$ и рассматривать ее как векторную величину, необходимо добавить аттрибут <<type=vector>> к элементу, отвечающему за отображение этой самой переменной.
      

      Как и в разметке представления, в Content Markup в основе лежит дерево выражения, точно также терминальные узлы представляются как базовые математические объекты, такие как числа, переменные или арифметические операции. Внутренние же элементы представляют собой более сложный объект, чем в Presentation Markup. В Content Markup гораздо больше элементов, которые условно можно разделить на следующие группы:


        \begin{itemize}
          \item \textbf{константы и символы}:  cn, ci, csymbol;

          \item \textbf{конструкции выражений} --- определяют сущность выражения или его части, будет ли оно, скажем, интервальным значением или выражением--условием:  apply, interval, inverse, sep, condition и др.;

          \item \textbf{арифметика, алгебра, логические операции}:   factorial, divide, max, min, minus, plus, power, rem, times, root, and, or, xor, not и др.;

          \item \textbf{отношения между выражениями}:  eq, neq, geq, leg, euivalint, approx, factorof;

          \item \textbf{интегральные и другие вычисления}:  int, diff, partialdiff, lowlimit, uplimit, bvar, degree, devergence, grad;

          \item \textbf{наборы}:  set, list, union, intersect, in, notin, subset, prsubset и др.;

          \item \textbf{последовательности}: sequences and series:  sum, product, limit;

          \item \textbf{классические функции}:  exp, ln, log, sin, cos, tan;

          \item \textbf{элементы статистики}:  mean, sdev, variance, median, mode, moment;

          \item \textbf{линейная алгебра}: vector, matrix, matrixrow, determinant, transpose, selector, vectorproduct;

          \item \textbf{семантическая взаимосвязь между элементами}:  annotation, semantics, annotation-xml;

          \item \textbf{константы и символьные переменные}: constant and symbol elements:  integers, reals, rationals, naturalnumbers, true, false, infinity и др.;
        \end{itemize}
        % ОФОРМЛЕНИЕ: как правильно пишется и др. (и другие) (и др.)
        % ОФОРМЛЕНИЕ: перечисление через точку с запятой? в конце точка? (если это отрывок предложения, ставится точка с запятой)
        % ОФОРМЛЕНИЕ: с большой буквы перечисление каждый раз или как? (на мнение автора)


        По сравнению с Presentation Markup, в случае с Content Markup будет сложнее предсказать, как в конечном итоге будет выглядеть математическое выражение. Кроме этого, некоторые операции, несущие разный семантический смысл при отображении могут выводиться одинаково или очень похоже.


      % написать про постфиксную форму content mathML
      
      
      % объяснить, почему для наших целей подходит ИМЕННО Presentation , а не Content Markup
 


  \section{Методы определения схожести упорядоченных деревьев} \label{chapt1__sect_methods}

  Математическое выражение, описываемое с помощью MathML, представляется в виде ориентированного упорядоченного дерева с неограниченным количеством дочерних узлов. Для того, чтобы в дальнейшем дать определение схожести двум математическим выражениям в формате MathML, в данном разделе рассматриваются методы определения схожести ориентированных упорядоченных деревьев.

  Для большей наглядности алгоритмов определения схожести тем или иным методом все они будут рассматриваться на примере деревьев $T_0$, $T_1$ и $T_2$ (рис.\ref{img:TrSimMetric_query}), для которых будет подсчитываться схожесть между деревом $T_0$ и деревьями $T_1$ и $T_2$.

    \begin{figure}[ht] 
      \center
      \includegraphics[width=.7\linewidth]{img/tikzpictures/chapt_1/t0t1t2}
      \caption{Упорядоченные ориентированные деревья $T_0$, $T_1$ и $T_2$} 
      \label{img:TrSimMetric_query}  
    \end{figure}

   Верхние индексы у узлов деревьев на рис.~\ref{img:TrSimMetric_query} определяют дерево, в котором они находятся --- так, к примеру, у дерева $T_0$ все верхние индексы имеют значение равным 0. 
   Нижние индексы определяют, какими по счету встречаются одинаковые узлы в своем дереве --- к примеру, у дерева $T_2$ есть два одинаковых узла $g$, первый из которых будет иметь нижний индекс равным 1, а второй равным 2.
   При исследовании некоторых методов индексы будут опускаться для большей наглядности.


    
    \subsection{Метод, основанный на введении дистанции редактирования между деревьями} \label{chapt1__sect_methods__tree_edit_dist}
    

      В работе~\cite{tree_sim_metric__edit_operations_distance1} схожесть двух деревьев определяется дистанцией между двумя упорядоченными деревьями (Edit Tree Distance). Под дистанцией понимается минимальное количество операций редактирования, таких как вставка, удаление и изменение узлов, чтобы преобразовать одно дерево в другое.

      Пусть $S$ --- последовательность $\{ s_1, s_2, \dots, s_k\}$ операций редактирования для преобразования одного дерева в другое. 

      Пусть $\gamma$ --- метрика дистанции между двумя деревьями, характеризующаяся неотрицательным весом для операции редактирования узла $a \rightarrow b$. Веса для разных узлов могут быть различными в зависимости от их значимости или расположения относительно корня дерева. На метрику вводятся следующие ограничения: 

        \begin{itemize}
          \item $\gamma(a \rightarrow b) \eqslantgtr 0$
          \item $\gamma(a \rightarrow b) = \gamma(b \rightarrow a)$
        \end{itemize}


      Применяя метрику дистанции к последовательности $S$ получаем следующую формулу: $\gamma (S) = \sum_{i=1}^{|S|} \gamma(s_i)$. Тогда дистанция между двумя выражениями: 

        \begin{equation}
          \label{eq:TrSimMetric_algo_tree_edit_dist__distfunc}
          \delta(T_1, T_2) = min\{\gamma (S)\}
        \end{equation}


      Применимо к рассматриваемым деревьям $T_0$, $T_1$ и $T_2$, преобразуем запрашиваемое дерево $T_0$ к дереву $T_1$ (рис.~\ref{img:TrSimMetric_algo_tree_edit_dist__T0_T1}) и к дереву $T_2$ (рис.~\ref{img:TrSimMetric_algo_tree_edit_dist__T0_T2}).

        \begin{figure}[ht] 
            \center
            \includegraphics[width=.68\linewidth]{img/tikzpictures/chapt_1/editDistance1}
            \caption{Приведение дерева $T_0$ к дереву $T_1$ с помощью операций редактирования} 
            \label{img:TrSimMetric_algo_tree_edit_dist__T0_T1}  
        \end{figure}


        \begin{figure}[ht] 
            \center
            \includegraphics[width=.98\linewidth]{img/tikzpictures/chapt_1/editDistance2}
            \caption{Приведение дерева $T_0$ к дереву $T_2$ с помощью операций редактирования} 
            \label{img:TrSimMetric_algo_tree_edit_dist__T0_T2}  
        \end{figure}

      Как видно из рис.~\ref{img:TrSimMetric_algo_tree_edit_dist__T0_T1} и рис.~\ref{img:TrSimMetric_algo_tree_edit_dist__T0_T2}, для того, чтобы преобразовать дерево $T_0$ к дереву $T_1$, требуется последовательность из двух операций добавления, а для того чтобы преобразовать дерево $T_0$ к дереву $T_2$ --- последовательность из четырех операций: одной операции удаления, и трех операций добавления узлов.


      Применяя формулу \ref{eq:TrSimMetric_algo_tree_edit_dist__distfunc} с весами всех узлов равными~1, получаем схожесть между запрашиваемым деревом $T_0$ и деревьями $T_1$ и $T_2$, равными $S_{TED}(T_0, T_1) = 2$ и $S_{TED}(T_0, T_2) = 4$ соответственно.

      Различные алгоритмы, в основе которых лежит данный метод, по-разному находят последовательность $S_i$, чтобы преобразовать одно дерево к другому. В работах \cite{tree_sim_metric__edit_operations_distance1}, \cite{tree_sim_metric__edit_operations_distance2}, \cite{tree_sim_metric__edit_operations_distance3}, \cite{tree_sim_metric__edit_operations_distance4} приведены четыре разных алгоритма по нахождению дистанции между двумя упорядоченными графами. При реализации последнего (RTED) учтены все слабые стороны ранних алгоритмов, и его можно считать, на момент написания диссертации, самым оптимальным.
      Алгоритмические сложности данных алгоритмов представлены в табл.~\ref{tbl:tree_edit_dist__comparison}.

        \begin{table} [htbp]
          \centering
          \caption{Сравнение алгоритмов, реализующих метод tree edit distance}\label{tbl:tree_edit_dist__comparison}
          \begin{tabular}{| p{1.9cm} | p{1.9cm} | p{1.9cm} | p{3.2cm}l |}
            \hline
            \centering Название алгоритма & \centering Средняя скорость выполнения &\centering Объем занимаемой памяти & Особенности &\\
            \hline
            TED~\cite{tree_sim_metric__edit_operations_distance1}  & $O(n^4)$     & $O(n^2)$  & Эффективен для сбалансированных деревьев & \\
            \hline
            ODTED~\cite{tree_sim_metric__edit_operations_distance3}    & $O(n^3)$     & $O(n^2)$  & Часто скорость выполнения ухудшается на сбалансированных деревьях & \\
            \hline
            RTED~\cite{tree_sim_metric__edit_operations_distance4}              & $O(n^3)$     & $O(n^2)$  & Хорошо себя проявляет в любых ситуациях & \\
            \hline
          \end{tabular}
        \end{table}


    \subsection{Метод, основанный на наложении одного дерева на другое}\label{chapt1__sect_methods__tree_overlap}
    
      Схожесть двух деревьев можно определить количеством общих узлов при наложении одного дерева на другое.
      В работе \cite{tree_sim_metric__overlap_subpath} приводится алгоритм на основе данного метода. Схожесть по данному алгоритму определяется количеством общих узлов с одинаковыми правилами перехода к последующим узлам при таком наложении одного дерева на другое, когда это количество будет наибольшим (Tree Overlapping). Правилом перехода является правило, по которому один узел переходит в какой--то другой или несколько других.  
      Под наложением одного дерева на другое данным алгоритмом подразумевается наложение узла первого дерева на такой же узел во втором дереве. Последующие узлы деревьев при совпадении также накладываются друг на друга. Пример наложения $T_0$ на $T_1$ и $T_0$ на $T_2$ из рассматриваемых деревьев в схожих узлах продемонстрирован на рис.~\ref{img:TrSimMetric_algo_overlap1} и на рис.~\ref{img:TrSimMetric_algo_overlap2} соответственно.

        \begin{figure}[ht] 
          \center
          \includegraphics[width=.7\linewidth]{img/tikzpictures/chapt_1/overlap1}
          \caption{Пример наложения дерева $T_0$ и $T_1$ в узлах $a^0_1$ и $a^1_1$} 
          \label{img:TrSimMetric_algo_overlap1}  
        \end{figure}

        \begin{figure}[ht] 
          \center
          \includegraphics[width=.7\linewidth]{img/tikzpictures/chapt_1/overlap2}
          \caption{Пример наложения дерева $T_0$ и $T_2$ в узлах $b^0_1$ и $b^1_1$} 
          \label{img:TrSimMetric_algo_overlap2}  
        \end{figure}


    
      В рассматриваемых примерах сразу были наложены <<самые удачные>> и единственные узлы, которые приводят к наибольшему количеству общих правил перехода между деревьями. В целом, таких вариантов наложений может быть много, в зависимости от того, какие узлы выбираются. 
      В случае с наложением узла $a^0_1$ дерева $T_0$ на узел $a^1_1$ дерева $T_1$ --- $C_{TO} (a^0_1, a^1_1) = 2$, а при наложении узла $b^0_1$ дерева $T_0$ на узел $b^2_1$ дерева $T_2$ схожесть будет равна $C_{TO} (b^0_1, b^2_1) = 1$.


      Схожесть деревьев по этой метрике определяется следующей формулой:

        \begin{equation}
          \label{eq:TrSimMetric_algo_overlap_Sto1}
          S_{TO}(T_1, T_2) = \max_{n_1 \in NT(T_1), n_2 \in NT(T_2)} C_{TO} (n_1, n_2)
        \end{equation}
        

      В формуле \ref{eq:TrSimMetric_algo_overlap_Sto1} $NT(T)$ --- набор нетерминальных узлов в дереве $T$.
      
      Схожесть между деревом $T_0$ и $T_1$ будет равна $S_{TO}(T_0, T_1) = 2$, а между деревом $T_0$ и $T_2$ равна $S_{TO}(T_0, T_2) = 1$.

      При наложении узлов друг на друга между деревьями при поиске схожести этим методом они должны совпадать в названии и в правилах перехода к последующим узлам. Алгоритм по нахождению максимально схожего дерева дереву $T_0$ из корпуса деревьев можно ускорить, не вычисляя поочередно схожесть каждого дерева из набора с запрашиваемым деревом. Для этого необходимо составить таблицу индексов $I[p]$ для корпуса деревьев, по которым будем искать схожесть с запрашиваемым деревом. Приведем пример и составим такую таблицу для корпуса деревьев $T_1$ и $T_2$ (рис.~\ref{img:TrSimMetric_query}) --- деревьях, рассматриваемых в качестве примера в этом разделе:

        \begin{table} [htbp]%
            \centering
            \caption{Таблица индексов для корпуса деревьев~$T_1$~и~$T_2$}%
            \label{tbl:TrSimMetric_overlap_idx}
            \renewcommand{\arraystretch}{1.1}
          \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                \toprule
              $p$ & $I[p]$  \\
                \midrule 
              $a \rightarrow b \, c$    & $\{a^1_1\}$\\
              $b \rightarrow d \, e$    & $\{b^1_1, b^2_1\}$\\
              $e \rightarrow g$         & $\{e^1_1\}$\\
              $g \rightarrow i$         & $\{g^1_1, g^2_1\}$\\
              $a \rightarrow g \, b$    & $\{a^2_1\}$\\
              $g \rightarrow j$         & $\{g^2_2\}$\\
                \bottomrule
          \end{tabular}%
        \end{table}
        

      В левом столбце табл.~\ref{tbl:TrSimMetric_overlap_idx} содержатся правила перехода от одного узла к другому(им). В правом --- список узлов, содержащихся в деревьях корпуса с представленным в левом столбце правилом перехода. Из табл.~\ref{tbl:TrSimMetric_overlap_idx} видно, что правилу перехода $b \rightarrow d \, e$ соответствуют сразу два узла из двух разных деревьев. Помимо этого, при рассмотрении других случаев, может быть такая ситуация, когда одному и тому же правилу перехода могут соответствовать сразу несколько узлов из одного и того же дерева. Составим такую же таблицу для запрашиваемого дерева $T_0$:


        \begin{table} [htbp]%
            \centering
            \caption{Таблица индексов для дерева~$T_0$}
            \label{tbl:TrSimMetric_overlap_idx_query}
            \renewcommand{\arraystretch}{1.1}
          \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                \toprule
              $p$ & $I[p]$  \\
                \midrule 
              $a \rightarrow b \, c$    & $\{a^0_1\}$\\
              $b \rightarrow d \, e$    & $\{b^0_1\}$\\
                \bottomrule
          \end{tabular}%
        \end{table}


      После составления таблиц индексов $I[p]$, необходимо составить таблицу Top --- Левый столбец в таблице будет указывать на совпавшие узлы между запрашиваемым деревом и деревьями корпуса, а правый --- на совпавшие вышележащие узлы относительно узлов в левом столбике, при проходе до которых все промежуточные узлы в деревьях с индексом этих узлов тоже совпадают. Пример данной таблицы для рассматриваемых в качестве примера деревьев (рис.~\ref{img:TrSimMetric_query}):


        \begin{table} [htbp]%
            \centering
            \caption{Таблица Top между узлами дерева $T_0$ и узлами деревьев корпуса~$T_1$~и~$T_2$}
            \label{tbl:TrSimMetric_overlap_top01}
            \renewcommand{\arraystretch}{1.1}
          \begin{tabular}{@{}@{\extracolsep{20pt}}ll@{}} 
                \toprule
              $(n,m)$ & $top(n,m)$\\
                \midrule 
              $\{a^0_1, a^1_1\}$    & $\{a^0_1, a^1_1\}$\\
              $\{b^0_1, b^1_1\}$    & $\{a^0_1, a^1_1\}$\\
              $\{b^0_1, b^2_1\}$    & $\{a^0_1, a^2_1\}$\\
                \bottomrule
          \end{tabular}%
        \end{table}


      Далее, необходимо подсчитать $C[n,m]$, который будет показывать количество наложенных друг на друга узлов начиная с узлов $n$ и $m$ с использованием таблиц индексов (табл.~\ref{tbl:TrSimMetric_overlap_idx} и табл.~\ref{tbl:TrSimMetric_overlap_idx_query}) и таблицы top (табл.~\ref{tbl:TrSimMetric_overlap_top01}) для деревьев корпуса. 
      
      Для этого применяется следующий алгоритм:

        \begin{enumerate}
          \item Находим по таблице индексов из столбца $I[p]$ одинаковые узлы с узлами запрашиваемого дерева $T_0$, положим пара таких узлов будет $(n, m)$;
          \item ищем по таблице $top$ вышележащие узлы, по пути к которым все промежуточные узлы совпадают, положим эти узлы $(n', m')$;
          \item увеличиваем значение $C(n', m')$ на 1.
        \end{enumerate}


      После применения данного алгоритма получаем следующие результаты:
      $C[a^0_1, a^1_1] = 2$,
      $C[a^0_1, a^2_1] = 1$  

      Преобразуем формулу~\ref{eq:TrSimMetric_algo_overlap_Sto1} для ее применения для оценки схожести между запрашиваемым деревом $T_0$ и деревом корпуса:

        \begin{equation}
          \label{eq:TrSimMetric_algo_overlap_Sto2}
          S_{TO}(T_0, T) = \max_{n \in NT(T_0), m \in NT(T)} C[top(n,m)]
        \end{equation}

      Применяя эту формулу~\ref{eq:TrSimMetric_algo_overlap_Sto2} получаем схожесть между запрашиваемым деревом $T_0$ и деревьями $T_1$ и $T_2$ равными $S_{TO}(T_0, T_1) = 2$ и $S_{TO}(T_0, T_2) = 1$ соответственно.
    

      При таком подходе объем занимаемой памяти при предварительной индексации корпусов деревьев составляет алгоритмическую сложность порядка $O(PR)$, где $PR$ --- количество правил перехода в таблице индексов.


    \subsection{Метод, основанный на подсчете количества общих подпутей между деревьями} \label{chapt1__sect_methods__subpath}
    

      В работе \cite{tree_sim_metric__overlap_subpath} схожесть двух деревьев определяется количеством общих подпутей между ними (Subpath Set). Подпутем является путь от корневого узла или одного из узлов в дереве до терминального или до другого узла по пути к нему. 

        \begin{figure}[ht] 
          \center
          \includegraphics[width=\linewidth]{img/tikzpictures/chapt_1/subpath1}
          \caption{Подпути деревьев $T_0$ и $T_2$} 
          \label{img:TrSimMetric_algo_subpath1}  
        \end{figure}

        \begin{figure}[ht] 
          \center
          \includegraphics[width=\linewidth]{img/tikzpictures/chapt_1/subpath2}
          \caption{Подпути деревьев $T_0$ и $T_2$} 
          \label{img:TrSimMetric_algo_subpath2}  
        \end{figure}


      На рис.~\ref{img:TrSimMetric_algo_subpath1} и рис.~\ref{img:TrSimMetric_algo_subpath2} можно увидеть набор общих подпутей между рассматриваемыми в качестве примера (рис.~\ref{img:TrSimMetric_query}) деревом $T_0$ и $T_1$ и между  деревом $T_0$ и $T_2$. 
      Согласно этому методу, схожесть между деревом $T_0$ и деревьями $T_1$ и $T_2$ будет равна $S_{ss}(T_0, T_1)=11$ и $S_{ss}(T_0, T_2)=9$ соответственно.


      Алгоритм по нахождению максимально схожего дерева дереву $T_0$ из набора деревьев $TS$ можно ускорить, не вычисляя поочередно схожесть каждого дерева из набора с запрашиваемым деревом. Для этого необходимо составить таблицу индексов $I[p]$ для корпуса деревьев, по которым будем искать схожесть с запрашиваемым деревом. Приведем пример и составим такую таблицу для корпуса деревьев $T_1$ и $T_2$ (рис.~\ref{img:TrSimMetric_query}):

        \begin{table} [htbp]%
            \centering
            \caption{Таблица индексов}%
            \label{tbl:TrSimMetric_subpath_idx}
            \renewcommand{\arraystretch}{1.1}
          \begin{tabular}{@{}@{\extracolsep{20pt}}ll|ll@{}} 
                \toprule
              $p$ & $I[p]$ & $p$ & $I[p]$\\
                \midrule 
              $a$   & $\{1, 2\}$        &     $e \rightarrow g$ & $\{1, 2\}$\\
              $b$   & $\{1, 2\}$        &     $g \rightarrow i$ & $\{1, 2\}$\\
              $c$   & $\{1\}$           &     $a \rightarrow g$ & $\{2\}$\\
              $d$   & $\{1, 2\}$        &     $g \rightarrow j$ & $\{2\}$\\
              $e$   & $\{1, 2\}$        &     $a \rightarrow b \rightarrow d$ & $\{1, 2\}$\\
              $g$   & $\{1, 2\}$        &     $a \rightarrow b \rightarrow e$ & $\{1, 2\}$\\
              $i$   & $\{1, 2\}$        &     $b \rightarrow e \rightarrow g$ & $\{1, 2\}$\\
              $j$   & $\{2\}$           &     $e \rightarrow g \rightarrow i$ & $\{1\}$\\

              $a \rightarrow b$ & $\{1, 2\}$  & $a \rightarrow g \rightarrow i$ & $\{2\}$\\
              $a \rightarrow c$ & $\{1\}$     & $e \rightarrow g \rightarrow j$ & $\{2\}$\\
              $b \rightarrow d$ & $\{1, 2\}$  & $a \rightarrow b \rightarrow e \rightarrow g$ & $\{1, 2\}$\\
              $b \rightarrow e$ & $\{1, 2\}$  & $b \rightarrow e \rightarrow g \rightarrow i$ & $\{1\}$\\
              && $b \rightarrow e \rightarrow g \rightarrow j$ & $\{2\}$\\
                \bottomrule
          \end{tabular}%
        \end{table}
        \newpage

      %%% ОПИСАНИЕ К ТАБЛИЦЕ (куда пихать?)
      В столбце $p$ содержаться все подпути деревьев корпуса, в столбце $I[p]$ указывается список деревьев из корпуса, в которых есть данный подпуть. 
      %%%

      Для каждого из подпутей запрашиваемого дерева, проходимся по столбцу $p$ в поиске идентичного подпути. При совпадении, из правого столбца извлекаем информацию, в каком из деревьев из корпуса содержится данный подпуть. 
      
      При таком подходе объем занимаемой памяти при предварительной индексации корпусов деревьев составляет алгоритмическую сложность порядка $O(L * D^2)$, где $L$ и $D$ -- максимальное количество листьев и максимальная глубина среди деревьев корпуса соответственно. 
     

    \subsection{Метод, основанный на подсчете количества общих поддеревьев между деревьями} \label{chapt1__sect_methods__tree_kernal}
    
      Впервые в работе \cite{tree_sim_metric__tree_kernal1} схожесть двух деревьев определяется количеством общих поддеревьев между ними (Tree Kernal). Понятие поддерева было введено в книге \cite{Beyondgrammar} и определяется следующим образом:
        \begin{itemize}
          \item Поддерево $t$ состоит более чем из одного узла дерева $T$;
          \item узлы поддерева $t$ должны содержать то же самое количество дочерних узлов что и узлы дерева $T$.
        \end{itemize}

       Поддеревья для рассматриваемых деревьев (рис.~\ref{img:TrSimMetric_query}) $T_0$ и $T_1$ продемонстрированы на рис.~\ref{img:TrSimMetric_algo_tree_kernal_T0T1}. В силу большого количества поддеревьев дерева $T_2$, поддеревья между $T_0$ и $T_2$ продемонстрированы не будут.

       
        \begin{figure}[ht] 
          \center
          \includegraphics[width=.75\linewidth]{img/tikzpictures/chapt_1/treeKernel1}
          \caption{Поддеревья деревьев $T_0$ и $T_1$} 
          \label{img:TrSimMetric_algo_tree_kernal_T0T1}  
        \end{figure}

      

      Из рис.~\ref{img:TrSimMetric_algo_tree_kernal_T0T1} можно сделать вывод, что дерево $T_0$ содержит 3 общих поддерева с деревом $T_1$. Количество общих поддеревьев между деревом $T_0$ и деревом $T_2$ равно 2. В этом случае схожесть между деревьями определяется как $S_{TK}(T_0, T_1)=3$ и $S_{TK}(T_0, T_2)=2$.

      Для метода нахождения общих поддеревьев было разработано несколько алгоритмов. Самым большим недостатком первого из них (TK) --- быстрое возрастание занимаемой памяти с количеством узлов в дереве из-за генерации огромного количества поддеревьев. Алгоритмы, разработанные позднее, позволили находить общие поддеревья, расходуя разумное количество памяти и не генерируя для каждого дерева все поддеревья. Одним из самых новых и эффективных можно считать (FTK). В табл.~\ref{tbl:tree_kernel__comparison} приведена эффективность алгоритмов TK и FTK.


        \begin{table} [htbp]
          \centering
          \caption{Сравнение алгоритмов FK и FTK, реализующий метод нахождения общх поддеревьев}
          \label{tbl:tree_kernel__comparison}
          \begin{tabular}{| p{2.0cm} | p{2.3cm} | p{3.2cm}l |}
            \hline
            \centering Название алгоритма & \centering Средняя скорость выполнения &\centering Объем занимаемой памяти &\\
            \hline
            TK  & \centering-     & $O(2^n)$   & \\
            \hline
            FTK     & $O(N_{T_1} + N_{T_2})$     & $O(N_{T_1} * N_{T_2})$  & \\
            \hline
          \end{tabular}
        \end{table}

      
    \subsection{Сравнение исследованных методов} \label{chapt1__sect_methods__comparison}


      Для каждого из исследованных методов определения схожести была подсчитана схожесть между деревом $T_0$ и деревьями корпуса, состоящего из двух деревьев --- $T_1$ и $T_2$, рассматриваемыми в качестве примера (рис.~\ref{img:TrSimMetric_query}). Ниже приведена табл.~\ref{tbl:methods_comparison}, обобщающая полученные результаты. 


        \begin{table} [htbp]
          \centering
          \caption{Сравнительная таблица схожестей между деревом $T_0$ и корпусом из деревьев $T_1$ и $T_2$ разными методами}
          \label{tbl:methods_comparison}
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{| p{3.4cm} | p{2.8cm} | p{3.2cm}l |}
            \hline
            \centering Метод & \centering Схожесть & \centering Что определяет число схожести &\\

            \hline
            Введение дистанции редактирования &
            $S_{TED}(T_0,T_1) = 2$  
            $S_{TED}(T_0,T_2) = 4$&
            кол--во операций, чтобы превратить одно дерево в другое &\\

            \hline
            Наложение одного дерева на другое &
            $S_{TO}(T_0,T_1) = 2$ 
            $S_{TO}(T_0,T_2) = 1$& 
            кол--во узлов с одинаковыми правилами перехода при <<наилучшем>> наложении деревьев&\\

            \hline
            Подсчет общих подпутей между деревьями & 
            $S_{SS}(T_0, T_1) = 11$ 
            $S_{SS}(T_0, T_2) = 9$&
            кол--во общих подпутей &\\

            \hline
            Подсчет общих поддеревьев между деревьями & 
            $S_{TK}(T_0, T_1) = 3$ 
            $S_{TK}(T_0,T_2) = 2$&
            кол--во общих поддеревьев &\\
            \hline

          \end{tabular}
        \end{table}


        Из табл.~\ref{tbl:methods_comparison} можно сделать вывод о том, что каждый результат не нормирован, и их сравнение между собой вызывает определенные трудности. В дальнейшем необходимо вводить какую--либо метрическую оценку схожести на основе одного из представленных методов.


      
  \section{Текущие реализации систем по поиску схожих математических выражений на основе рассмотренных методов}

    Исследованные алгоритмы и методы, лежащие в их основе, по определению схожести упорядоченных деревьев нашли широкое применение в области машинного обучения при анализе естественных языков. В ходе исследовательской части было найдено две поисковые системы, которые позволяют сравнивать MathML выражения между собой. Алгоритмы поиска, заложенные в их основу, применяют метод поиска общих подпутей и метод введения дистанции между двумя деревьями с помощью операций редактирования.


    \subsection{Поисковая система с алгоритмом нахождения общих подпутей} \label{chapt1__sect_retr_tool__uses_subpath}

      В работе \cite{retr_tool__algo_subpath} на основе алгоритма поиска схожих между деревьями подпутей, рассмотренного ранее в параграфе~\ref{chapt1__sect_methods__subpath}, была разработана система по поиску схожих выражений по заданному. Поскольку результатом применения алгоритма служит количество общих подпутей между деревом $T_1$ и $T_2$, то необходимо было ввести какую--либо метрическую оценку схожести. Авторы применяют коэффициент Жаккара:

      \begin{equation}
          \label{eq:JaccardCoeff_algo_subpath}
          K_{J} = \frac{S(T_1) \cap S(T_2)}{S(T_1) \cup S(T_2)}
      \end{equation}
  
      В формуле \ref{eq:JaccardCoeff_algo_subpath} $S(T_i)$ --- набор подпутей дерева $T_i$.
      В качестве корпуса авторы используют более 150 тысяч формул, собранных с сайта Wolfram \cite{wolfram_functions}, написанных в Presentation Markup, и с использованием Content Markup в качестве аннотаций.

      В их работе представлены оценки по результативности поиска методом поиска общих подпутей. Результаты можно увидеть на рис.~\ref{img:retr_tool__uses_subpath___result}. Столбцы $P$ и $C$ содержат числа, указывающие, каким по счету по схожести было найдено ожидаемое выражение. В случае, если оно не было найдено в первых ста найденных выражениях, значение помечалось знаком $x$.

        \begin{figure}[ht] 
          \center
          \includegraphics [width=\linewidth] {img/retr_tool__uses_subpath___result}
          \caption{Результат поиска схожих математических выражений алгоритмом subpath для выражений в разметке Presentation Markup и Content Markup} 
          \label{img:retr_tool__uses_subpath___result}  
        \end{figure}
        

      Авторы разработанной системы отметили, что при использовании данного алгоритма с выражениями, представленными в Presentation Markup, результаты были неудовлетворительными --- одна из причин может быть в том, что функции и операции, в Presentation Markup обозначаются одним и тем же символом <<$mo$>>, и при подсчете многих общих подпутей, содержащих данный символ, не учитывается эта особенность.
      


    \subsection{EMERS} \label{chapt1__sect_retr_tool__EMERS}

      В работе~\cite{retr_tool__EMERS} на основе метода введения дистанции между деревьями, рассмотренного ранее в параграфе~\ref{chapt1__sect_methods__tree_edit_dist}, была разработана система EMERS по оценки качества распознавания математических выражений. Под распознанным математическим выражением понимаетсяы выражение в формате MathML, полученное в ходе распознавания выражения с изображения.
      

      EMERS был разработан с учетом следующей особенности при распознавании математических нотаций --- распознование символов может иметь разную степень сложности. 

      Рассмотрим два математических фрагмента: $a^i$ и $e^{c^i_k}$. Оба из них содержит надстрочный индекс. Предположим, в результате распознавания этих фрагментов в первом случае система распознала один из них $ai$, а во втором --- $e^{c^i k}$. Оба из них содержат одну ошибку, однако, не совсем корректно считать их равнозначными: можно сказать, что ошибка в первом случае более значима, чем во втором. 

      Для того, чтобы ввести разный уровень значимости в работе \cite{Horizlev}, были определены горизонтальные уровни для каждого символа. Базовый символ имеет значение горизонтального уровня равное 0. В зависимости от того, насколько высоко находится элемент относительно базового, ему присваивается значение горизонтального уровня равным $\{+1 +2 \dots +n\}$ соответственно. Аналогично $\{-1 -2 \dots -m\}$ для низлежащих элементов.
      
      Было предложено давать штраф за ошибку в символе со значением горизонтального уровня $k$ равное: 

      \begin{equation}
        \label{eq:horizontlevPenalty}
        penalty = \frac{1}{|k|+1}
      \end{equation}

      К примеру, для выражения $e^{c^i}$ значения горизонтального уровня для символов $e, c$ и $i$ будут равны $0, 1$ и $2$. В случае допущения ошибки в символе $c$ значение штрафа будет $\frac{1}{|1|+1} = 0.5$, а при ошибке в $i$ штраф будет меньше и равен --- $\frac{1}{|2|+1} = 0.33$. 
      

      EMERS подсчитывает штраф за неправильно распознанный символ аналогичным образом --- чем выше или ниже горизонтальный уровень символа, тем ниже он будет, считая от корня дерева, в древовидном представлении выражения. EMERS за основу берет формулу штрафа \ref{eq:horizontlevPenalty}. Ввиду того, что  любой операции редактирования на основе алгоритма \ref{chapt1__sect_methods__tree_edit_dist} можно назначить произвольный вес, он назначается следующим образом:


      \begin{equation}
        \label{eq:costfunc}
        \gamma (a \rightarrow b) = 
        \begin{cases}
          0,              &\text{если $a=b$;}\\
          \frac{1}{L+1},  &\text{если $a \neq b$.}
        \end{cases}
      \end{equation}
      , где $(a \rightarrow b)$ --- операция изменения узла в дереве (операция замены, удаления, или вставки)

      EMERS находит дистанцию между распознанным выражением и его правильным представлением по формуле \ref{eq:TrSimMetric_algo_tree_edit_dist__distfunc}, рассмотренной в параграфе~\ref{chapt1__sect_methods__tree_edit_dist}. Ниже приведен пример сравнения двух выражений с помощью EMERS(рис.~\ref{img:retr_tool__EMERS___result}).
     


        \begin{figure}[ht] 
          \center
          \includegraphics [width=.4\linewidth] {img/retr_tool__EMERS___result}
          \caption{Пример сравнения выражений с помощью EMERS} 
          \label{img:retr_tool__EMERS___result}  
        \end{figure}

      % TOOOODOOOO (алгоритмическая сложность)









